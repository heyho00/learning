# useEffect

두 가지 일반적인 side effect가 있다.
**정리가 필요한것과 아닌 것.**

## 1. Effects without cleanup 정리하지 않은 효과

네트워크 요청, 수동 DOM 변형 및 로깅은 정리가 필요하지 않은 효과의 일반적인 예

클래스와 Hook이 이러한 effect를 표현하는 방법을 비교해 보자.

```jsx

//// class

class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  componentDidMount() {
    document.title = `You clicked ${this.state.count} times`;
  }
  componentDidUpdate() {
    document.title = `You clicked ${this.state.count} times`;
  }

  render() {
    return (
      <div>
        <p>You clicked {this.state.count} times</p>
        <button onClick={() => this.setState({ count: this.state.count + 1 })}>
          Click me
        </button>
      </div>
    );
  }
}


구성 요소가 방금 마운트되었는지 또는 업데이트 되었는지에 관계없이 동일한 effect를 원한다.
모든 렌더 후에 발생하기를 원하지만 class 구성 요소에는 이러한 메서드가 없다.


//// hook

import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `You clicked ${count} times`;
  });

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}


첫번째 렌더링 후 와 모든 업데이트 후에 실행된다.
마운팅 및 업데이트의 관점에서 생각하는 대신 렌더링 후 발생한다고 생각하면 쉽다.
```

componentDidMount, componentDidUpdate와 달리 useEffect로 예약된 효과는 브라우저가
화면을 업데이트하는 것을 차단하지 않는다. -> 앱의 응답성이 향상된다.

## 2. Effects with cleanup 정리가 필요한 효과

React 클래스에서는 일반적으로 componentDidMount에서 구독을 설정하고 componentWillUnmount에서 정리합니다.

```jsx
//// class

class FriendStatus extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isOnline: null };
    this.handleStatusChange = this.handleStatusChange.bind(this);
  }

  componentDidMount() {
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }
  componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }
  handleStatusChange(status) {
    this.setState({
      isOnline: status.isOnline
    });
  }

  render() {
    if (this.state.isOnline === null) {
      return 'Loading...';
    }
    return this.state.isOnline ? 'Online' : 'Offline';
  }
}

componentDidMount, componentWillUnmount 둘 다의 코드가 동일한 효과와 관련있음에도 불구하고 이 논리를 분할하도록 합니다.



////hook

import React, { useState, useEffect } from 'react';

function FriendStatus(props) {
  const [isOnline, setIsOnline] = useState(null);

  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    // Specify how to clean up after this effect:
    return function cleanup() {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  if (isOnline === null) {
    return 'Loading...';
  }
  return isOnline ? 'Online' : 'Offline';
}

같은 효과의 일부인 구독을 추가, 제거하는 논리를 서로 가깝게 유지할 수 있다.
```

<br>

## 여러 효과를 사용할 때

```jsx
//// class

class FriendStatusWithCounter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0, isOnline: null };
    this.handleStatusChange = this.handleStatusChange.bind(this);
  }

  componentDidMount() {
    document.title = `You clicked ${this.state.count} times`;
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  componentDidUpdate() {
    document.title = `You clicked ${this.state.count} times`;
  }

  componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  handleStatusChange(status) {
    this.setState({
      isOnline: status.isOnline
    });
  }


//// hook

function FriendStatusWithCounter(props) {
  const [count, setCount] = useState(0);
  useEffect(() => {
    document.title = `You clicked ${count} times`;
  });

  const [isOnline, setIsOnline] = useState(null);
  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }

    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });
  // ...
}



훅을 사용하면 수명 주기 메서드 이름이 아닌 수행중인 작업에 따라 코드를 분할할 수 있다.

class 에서는 구성 요소가 화면에 있는동안 prop이 변경되면 친구의 온라인 상태를 계속 표시한다.
이것은 버그이며 unsubscribe호출이 잘못된 친구 ID를 사용하므로 마운트 해제할 때 메모리 누수 또는 충돌이 발생한다.

hook에서는 useEffect가 업데이트를 알아서 처리하기 때문에 특별히 덧붙일 코드가 없다.
다음 효과를 적용하기 전에 이전 효과를 정리한다.

```

  <br>

## 성능 최적화

```jsx
//// class

componentDidUpdate(prevProps, prevState) {
if (prevState.count !== this.state.count) {
  document.title = `You clicked ${this.state.count} times`;
}
}

렌더링 할때마다 효과를 정리하거나 적용하면 성능 문제가 발생할 수 있다.
prevProps 클래스 구성 요소에서 또는 prevState 내부에 추가 비교를 작성하여
해결할 수 있다.


//// hook
useEffect(() => {
document.title = `You clicked ${count} times`;
}, [count]); // Only re-run the effect if count changes

재렌더링 간에 특정값이 변경되지 않은 경우 react에 효과 적용을 건너뛰도록 지시한다.
뒤에 [count]가 dependency로 배열의 항목이 동일하면 효과를 건너뛴다.



```
