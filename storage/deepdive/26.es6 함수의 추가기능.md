# ES6 함수의 추가 기능

ES6 이전까지 JS의 함수는 별다른 구분없이

일반함수, new 와 함께 생성자함수, 객체에 바인딩된 메서드로서 호출할 수 있었다.

언뜻보면 편리하지만 실수를 유발하고 성능 면에서도 손해란다.

다시말해 ES6이전의 모든 함수는 callable 이면서 constructor이다.

메서드라 부르던 객체에 바인딩된 함수도 마찬가지.

함수에 전달되어 보조 함수 역할을 하는 콜백까지도 constructor 이기 때문에 불필요한 프로토타입 객체를 생성한다.


이러한 문제를 해결하기 위해 세 종류로 구분함.

<img src="../../image/deepdive/함수타입.png" width="600" />

**ES6의 메서드와 화살표 함수는 non-constructor이다. !!!**

<br>

## 메서드

ES6사양에서 메서드 축약 표현으로 정의된 함수만 의미한다.

```js
const obj = {
    x:1,
    foo(){
        return this.x;
    },
    bar:function(){ return this.x}
}

console.log(obj.foo()) //1
console.log(obj.bar()) //1
```

인스턴스를 생성할 수 없는 non-constructor라고 했다.

```js
new obj.foo() // TypeError
new obj.bar() // bar {}
```

foo는 인스턴스도 프로토타입도 생성하지 않는다.

참고로 표준 빌트인 객체가 제공하는 프로토타입 메서드와 정적 메서드는 모두 non-constructor다.

(toUpperCase, isFinite, map, from ...)

<br>

ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 [[HomeObject]]를 갖는다.

super 참조는 내부 슬롯을 사용해 수퍼클래스의 메서드를 참조하므로 내부 슬롯을 갖는 메서드는 super 키워드를 사용할 수 있다.

```js

const base = {
    name: 'harry',
    sayHi(){
        return `hi ${this.name}`
    }
}

const derived = {
    __proto__:base,
    sayHi(){
        return `${super.sayHi()}. how r u ?`
    }
}

console.log(derived.sayHi()) // hi harry. how r u ?
```

메서드가 아닌 함수는 super 키워드를 사용할 수 없다.

```js

const derived = {
    __proto__:base,
    sayHi:function(){
        //SyntaxError 'super' keyword unexpected here
        return `${super.sayHi()}. how r u ?`
    }
}

```

본연의 기능을 추가하고 의미적으로 맞지 않는 constructor 기능은 제거했다.

따라서 메서드를 정의할 때 프로퍼티 값으로 익명 함수 표현식을 할당하는 이전의 방식을 사용하지 않는 것이 좋다.
