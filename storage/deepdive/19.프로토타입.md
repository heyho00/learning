# 프로토타입

JS는 프로토타입 기반의 객체지향 프로그래밍 언어.

클래스는 생성자 함수보다 엄격, 생성자 함수에서 제공하지 않는 기능도 제공.

<br>

## 객체지향 프로그래밍

프로그램을 명령어 또는 함수의 목록으로 보는 전통적인 명령형 프로그래밍의 절차지향적 관점에서 벗어나

여러 개의 독립적 단위, 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임.

프로그램에 필요한 속성만 간추려 내어 표현하는것을 `추상화`라 한다.

```js
const circle = {
  radius: 5,

  getDiameter() {
    return 2 * this.radius;
  },

  getperimeter() {
    return 2 * Math.PI * this.radius;
  },
  getArea() {
    return Math.PI * this.radius ** 2;
  },
};
```

객체의 상태를 나타내는 `데이터`와 상태 데이터를 조작할 수 있는 `동작`을

하나의 논리적인 단위로 묶어 생각한다.

따라서 객체는 **상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구조**라 할 수 있다.

<br>

## 상속과 프로토타입

어떤 객체의 프로퍼티 또는 메서드를 다른 객체가상속받아 그대로 사용할 수 있다.

```js
function Circle(radius) {
  this.radius = radius;
  this.getArea = function () {
    return Math.PI * this.radius ** 2;
  };
}

const circle1 = new Circle(1);
const circle2 = new Circle(2);
```

생성자 함수는 동일한 프로퍼티 구조를 갖는 객체를 여러개 생성할 때 유리.

하지만 문제는 인스턴스를 생성할 때마다 getArea메서드를 중복 생성, 중복 소유한다는 것. -> 메모리 낭비

상속을 통해 불필요한 중복을 제거할 수 있다.

JS는 프로토타입을 기반으로 상속을 구현한다.

```js
function Circle(radius) {
  this.radius = radius;
}

Circle.prototype.getArea = function () {
  return Math.PI * this.radius ** 2;
};

// 모든 인스턴스는 부모 객체의 역할을 하는 프로토타입 으로부터 getArea 메서드를 상속받는다.

const circle1 = new Circle(1);

console.log(circle1.getArea()); // 3.141592...
```

<br>

## **proto** 접근자 프로퍼티

모든 객체는 **proto** 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 간접 접근할 수 있다.

<img src="../../image/deepdive/프로토타입.png" alt="prototype" width="500">

Object.prototype의 접근자 프로퍼티로써 자체적으로 값은 갖지 않고

다른 데이터의 값을 익거나 저장할 때 사용. (getter/setter)

```js
const obj = {};
const parent = { x: 1 };

//getter 함수인 get __proto__가 호출되어 obj객체의 프로토타입을 취득
obj.__proto__;

//setter 함수인 set __proto__가 호출되어 objrorcpdml 프로토타입을 교체
obj.__proto__ = parent;

console.log(obj.x); // 1
```

<br>

프로토타입 체인은 단방향 링크드 리스트로 구현되어야 한다.

검색 방향이 한쪽 방향으로만 흘러야 한다는 의미.

코드내에서 직접 **proto**를 쓰는것은 권장되지 않는다.

모든 객체가 **proto** 접근자 프로퍼티를 사용할 수 있는건 아니기 때문.

```js
const obj = Object.create(null);

// 메서드를 사용하는 편이 좋다.
console.log(Object.getPrototype(obj)); // null

// 교체는
const obj = {};
const parent = { x: 1 };

Object.getPrototypeOf(obj); // obj.__proto__;

Object.setPrototypeOf(obj, parent); // obj.__proto__ = parent;

console.log(obj.x); //1
```

<br>

화살표 함수와 ES6 메서드 축약 표현으로 정의한 메서드는 prototype 프로퍼티를

소유하지 않으며 프로토타입도 생성하지 않는다.

```js
function Person(name) {
  this.name = name;
}

const me = new Person("Lee");

console.log(Person.prototype === me.__proto__); //true
```

<br>

```js
//생성자 함수
function Person(name) {
  this.name = name;
}

const me = new Person("Lee");

console.log(me.constructor === Person); //true
// me 객체는 프로토타입의 constructor프로퍼티를 통해 생성자 함수와 연결.
// me 객체에는 constructor 프로퍼티가 없지만 me의 프로토타입인 Person.prototype에는 있다.
// Person.prototype의 constructor프로퍼티를 상속받아 사용하는 것.
```

<br>

리터럴 표기법에 의해 생성된 객체도 물론 프로토타입이 존재.

하지만 constructor프로퍼티가 가리키는 생성자 함수가 반드시 생성자 함수라고 단정할 수 없다.

```js
const obj = {};

console.log(obj.constructor === Object); //true
```

Object 생성자 함수로 생성한 객체가 아니라 객체 리터럴에 의해 생성된건데

Object 생성자 함수와 constructor 프로퍼티로 연결되어 있다.

객체 리터럴이 평가될 때 추상연산이 호출되어 빈 객체를 생성하고 Object 프로토타입을 갖게한다.

```js
function foo() {}

console.log(foo.constructor === Function); //true

// 함수도 마찬가지

//가상적인 생성자 함수를 갖는다. -> constructor와 연결됨.
```

<br>

프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재.

프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.

호이스팅으로 런타임 이전에 함수 객체가 생성되는 시점에 프로토타입도 더불어 생성된다.

p.277
