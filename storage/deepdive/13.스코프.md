# 스코프

식별자가 유효한 범위.

모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다.

## Lexical scope

**코드가 어디서 실행되며 주변에 어떤 코드가 있는지.**

코드의 문맥(context)은 렉시컬 환경으로 이뤄진다.

이를 구현한 것이 실행 컨텍스트이며 모든 코드는 실행 컨텍스트에서 평가되고 실행된다.

<br>

### var 키워드로 선언한 변수의 중복 선언

같은 스코프 내에서 중복 선언이 허용된다. 의도치 않게 변수값이 재할당되어 변경되는 부작용을 발생시킨다.

```js
function foo() {
    var x =1;
    var x=2;
    console.log(x) //2
}



function bar(){
    let x=1;
    let x=2; // SyntaxError: Identifier 'x'has already been declared
}
bar()

```

<br>

## 스코프 체인

JS엔진이 스코프 체인을 통해 참조할 변수를 검색한다.

inner함수 내부의 x변수 이외에 전역 변수 x가 존재할때

inner함수 내부에서 x변수를 참조하면 전역변수 x가 아닌 inner함수 내부의 x를 참조한다.

<br>

## 함수 레벨 스코프

var 키워드로 선언된 변수는 오로지 함수의 코드블록(함수 몸체)만을 지역 스코프로 인정한다. 

이러한 특성을 `함수 레벨 스코프`라 한다.
```js
var x =1;

if(true){
    var x =10
}

console.log(x) // 10



var i = 10;

for(var i =0; i<5;i++){
    console.log(i) // 0, 1, 2, 3, 4
}

console.log(i) //5
```

의도치 않게 변수의 값이 변경된다.

let, const는 `블록 레벨 스코프`를 지원하기 때문에 사용이 권장된다.



<br>

## 렉시컬 스코프

```js
let x = 1;

function foo(){
    let x = 10;
    bar();
}

function bar() {
    console.log(x)
}

foo() // 1
bar() // 1
```

함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정하는 방식 -> `동적 스코프`

함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정하는 방식 -> `정적 스코프`, `렉시컬 스코프`

JS는 렉시컬 스코프를 따르므로 함수를 어디서 정의했는지에 따라 상위 스코프가 결정된다.

함수 bar는 전역에서 정의되었기 때문에 상위 스코프인 전역 스코프의 x를 참조한다. 따라서, 전부 1을 출력.

