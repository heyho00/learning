# 클래스

JS는 프로토타입 기반 객체지향 언어.

다른 객체지향 언어와 차이점에 대한 논쟁이 있지만 강력한 객체지향 프로그래밍 능력을 지녔다.

다음과 같이 생성자 함수와 프로토타입을 통해 객체지향 언어의 상속을 구현할 수 있다.

```js

var Person = (function(){
    //생성자 함수
    functin Person(name){
        this.name = name;
    }

    //프로토타입 메서드
    Person.prototype.sayHi = function(){
        console.log('Hi my name is' + this.name)
    }

    //생성자 함수 반환
    return Person;
},())

var me = new Person('Lee')
me.sayHi() // Hi my name is Lee
```

ES6에서 도입된 클래스는 사실 함수이며 기존 프로토타입 기반 패턴을 클래스 기반 패턴처럼

사용할 수 있도록 하는 문법적 설탕, syntactic sugar라고 볼 수도 있다.

단, 클래스와 생성자 함수는 프로토타입 기반 인스턴스를 생성하지만 정확히 동일한 동작을 하는건 아니다.

1. 클래스를 new 연산자 없이 호출하면 에러발생. 생성자 함수는 없이 호출하면 일반 함수로 호출됨.

2. 클래스는 상속을 지원하는 extends, super 키워드를 제공. 생성자 함수는 미지원.

3. 클래스는 호이스팅이 발생하지 않는 것처럼 동작. 함수 선언문으로 정의된 생성자 함수는 `함수 호이스팅`이, 함수 표현식으로 정의한 생성자 함수는 `변수 호이스팅`이 발생한다.

4. 클래스 내의 모든 코드에는 암묵적으로 strict mode. 생성자 함수는 암묵적으로 strict mode 미적용.

5. 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트의 값이 false. 열거되지 않는다.

둘은 매우 유사하지만

클래스는 생성자 함수 기반의 객체 생성 방식보다 견고하고 명료하다.

그렇다고 클래스가 JS의 다른 객체 생성방식보다 우월하다는건 아님.

따라서 클래스를 프로토타입 기반 객체 생성 패턴의 단순 문법적 설탕보다는 `새로운 객체 생성 매커니즘`으로 보는게 합당하다.

```js
//클래스 선언문
class Person {}

// 일반적이진 않지만, 
//익명 클래스 표현식
const Person = class {}

//기명 클래스 표현식
const Person = class MyClass {}
```

클래스를 표현식으로 정의할 수 있다는 것은

값으로 사용할 수 있는 일급 객체라는것을 의미. 다음의 특징을 갖는다.

- 무명의 리터럴로 생성가능, 즉, 런타임에 생성 가능.
- 변수나 자료구조(객체, 배열)에 저장 가능.
- 함수의 매개변수에 전달 가능.
- 함수의 반환값으로 사용 가능.

p453 / 419