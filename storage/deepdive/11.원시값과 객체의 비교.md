# 원시값과 객체의 비교

- 원시 타입의 값은 변경 불가. 객체는 변경 가능한 값.
- 원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다. 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.
- 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다.`(값에 의한 전달)` 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다.`(참조에 의한 전달)`

## 원시값

변경 불가능하다는 것은 변수가 아니라 값에 대한 진술이다.

변수는 언제든 재할당을 통해 변경할 수 있다.

상수는 재할당이 금지된 변수를 말한다.

```js
const o = {};

// const 키워드로 선언한 변수는 재할당이 금지된다.
// 그러나 할당한 객체의 경우 변경이 가능하다.

o.a = 1;
console.log(o); //{a:1}
```

원시 값을 할당한 변수에 재할당하면 메모리 공간에 저장돼 있는 원시 값을 변경하는 것이 아니라 새로운 메모리 공간을 확보하고 재할당한 원시 값을 저장한 후 변수는 새롭게 재할당한 원시 값을 가리킨다.
이러한 특성을 `불변성`이라 한다.

<br>

#### 유사배열객체

배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체.

문자열은 마치 배열처럼 인덱스를 통해 각 문자에 접근할 수 있고 length 프로퍼티를 갖기 때문에 유사 배열 객체이다.

```js
var str = "string";

console.log(str.toUpperCase()); // 'STRING' 값을 새로 생성할 뿐 str이 바뀌진 않는다.

-----

var str = 'string';

// 문자열은 유사 배열이므로 인덱스를 사용해 각 문자에 접근할 수 있으나 원시값이므로 변경은 되지 않는다.
str[0] = 'S'
console.log(str); // 'string'
```

<img src="../../image/deepdive/유사배열.png" alt="유사배열" width="400">

obj 객체에서 프로퍼티는 바뀔 수 있으나<br>
obj.name은 원시타입으로 바뀌지 않는다.

<br>

## 값에 의한 전달

```js
var score = 80;
var copy = score;

console.log(score); // 80
console.log(copy); // 80
// 이때 score와 copy의 80은 다른 메모리 공간에 저장된 별개의 값이다.

score = 100; // 100을 저장한 메모리 공간을 다시 가리키겠지

console.log(score); // 100
console.log(copy); // 80
```

사실 실제 자바스크립트 엔진의 내부 동작과 정확히 이리하지 않을 수 있다고 함.

ECMAScript사양에는 변수를 통해 메모리를 어떻게 관리해야 하는지 명확하게 정의되어 있지 않다고.

실제 내부 동작은 미묘한 차이가 있을 수 있다.

<img src="../../image/deepdive/변수복사.png" alt="변수복사" width="500">

같은 메모리를 참조하다가 score의 값을 바꿀때 가리키는 메모리 주소가 바뀌는 것.

다른 책에서는 이렇게 설명한 걸 본 듯하다..

`값에 의한 전달`이라는 용어는 사실 자바스크립트를 위한 용어가 아니란다.

엄격하게 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되기 때문이다.

결론은 '값에 의한 전달'도 사실은 값을 전달하는 것이 아니라 메모리 주소를 전달한다는 사실과 두 변수는 다른 메모리 공간을 가리키며 서로 간섭할 수 없다는 것.

<br>

## 객체

원시값과 다른 방식으로 동작하도록 설계돼있다.

프로퍼티 키를 인덱스로 사용하는 `해시 테이블`이라고 생각할 수 있다.

클래스 기반 객체지향 프로그래밍 언어는 사전에 정의된 클래스를 기반으로 인스턴스를 생성한다. 객체가 생성된 이후에는 프로퍼티를 삭제하거나 추가할 수 없다.

JS는 클래스 없이 객체를 생성할 수 있으며 생성된 이후에도 동적으로 프로퍼티와 메서드를 추가할 수 있다.

이는 사용하기는 매우 편리하지만 성능 면에서는 이론적으로 클래스 기반 언어의 객체보다 생성과 프로퍼티 접근에 비용이 더 많이 드는 비효율적인 방식이다.

<br>

### 변경 가능한 값

원시값에서는 변수가 기억하는 메모리 주소를 통해 값에 접근할 수 있었다.

객체를 할당한 변수에서는 기억하는 메모리 주소를 통해 참조값에 접근한다.

바로 값에 접근하는게 아니기 때문에 객체를 할당한 변수는 원시값과 다르게 재할당 없이 객체를 직접 변경할 수 있다.

프로퍼티, 메서드를 변경해도 객체를 할당한 변수의 참조값은 변경되지 않는다.

이렇게 변경 가능한 값으로 설계된 이유는 객체를 복사해 생성하는 비용을 절약, 메모리를 효율적으로 사용하기 위함이다.

메모리 사용의 효율과 성능을 위해 어느 정도의 구조적 단점을 감안한 설계로써 부작용이 있다. 그것은 원시값과 다르게 **여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것**이다.

<br>

## 얕은 복사와 깊은 복사
