# this

실행 컨텍스트가 생성될 때 함께 결정된다.
-> 실행컨텍스트는 함수를 호출할 때 생성되므로, 바꿔 말하면
this는 함수를 호출할 때 결정된다.

<br>

## 전역 공간에서의 this

```jsx
var a = 1;
window.b = 2;

console.log(a, window.a, this.a); //111
console.log(b, window.b, this.b); ///222

window.a = 3;
b = 4;
console.log(a, window.a, this.a); ///333
console.log(b, window.b, this.b); ///444
```

전역 변수를 선언하면 자바스크립트 엔진은 이를 전역 객체의 프로퍼티로 할당한다.

전역 공간에서 var로 변수를 선언하는 대신
window의 프로퍼티에 직접 할당해도 var로 선언한 것과 같이 똑같이 동작한다.

<br>

## However,..

'삭제' 명령에서는 다르다.

```jsx
var a = 1;
delete window.a; //false
console.log(a, window.a, this.a); //111

var b = 2;
delete b; //false
console.log(b, window.b, this.b); //222

window.c = 3;
delete window.c; //true
console.log(c, window.c, this.c); //Uncaught ReferenceError: c is not defined

window.d = 4;
delete d; //true
console.log(d, window.d, this.d); //Uncaught ReferenceError: d is not defined
```

전역 변수를 선언하면 자바스크립트 엔진이 이를 자동으로 전역객체의 프로퍼티로 할당하면서 해당 프로퍼티의 configurable속성 (변경 및 삭제 가능성)을 false로 정의해 삭제되지 않게한다.

-> 사용자가 의도치않게 삭제하는 것을 방지하기위한 차원이라함.

<br>

---

<br>

## 함수 vs 메서드

함수를 실행하는 일반적인 방법으로

1. 함수로서 호출하는 경우.
2. 메서드로서 호출하는 경우.

둘을 구분하는 유일한 차이는 `독립성`이고
함수 앞에 .이 있는지 여부로 구분한다.

- 함수는 그 자체로 독립적인 기능을 수행.
- 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행한다. 점이 있다.

```jsx
var func = function (x) {
  console.log(this, x);
};
func(1); //window{...} 1

var obj = {
  method: func,
};
obj.method(2); //{method:f} 2
```

함수로 호출하면 this가 전역객체 window가 되고
메서드로 호출되면 this가 obj가 된다.

<br>

---

<br>

## this를 우회하는 법.

```jsx
var obj = {
    outer: function(){
        ...

        var self = this;
        var innerFunc2 = function(){
            console.log(self); // {outer:f}
        }
        innerFunc2();
    }

}
obj.outer()
```

상위 스코프의 this를 저장해서 내부함수에서 활용하는 수단.

<br>

## this를 바인딩 하지 않는 화살표 함수가 도입됨.

```jsx
var obj = {
  outer: function () {
    console.log(this); // {outer:f}
    var innerFunc = () => {
      console.log(this); // {outer:f}
    };
    innerFunc();
  },
};
obj.outer();
```

<br>

---

<br>

## 명시적으로 this를 바인딩하는 방법

call,
apply,
bind 등...
다음 기회에...
