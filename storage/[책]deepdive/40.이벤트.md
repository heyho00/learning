# 이벤트

## 이벤트 드리븐 프로그래밍

이벤트가 발생했을 때 호출될 함수를 `이벤트 핸들러`라 한다.

브라우저가 사용자의 버튼 클릭이나 이벤트를 감지하여 위임받은 특정 함수를 호출한다.

이벤트와 그에 대응하는 함수를 통해 사용자와 애플리케이션은 상호작용 할 수 있다.

프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식을 `이벤트 드리븐 프로그래밍`이라 한다.

<br>

## 이벤트 핸들러 어트리뷰트 방식

```html
<body>
    <button onclick="sayHi('Lee')">Click me</button>
    <script>
        function sayHi(name) {
            console.log(`Hi, ${name}`)
        }
    </script>
</body>
```

이벤트 핸들러 등록이란 함수 호출을 브라우저에게 위임하는 것.

CBD (component based development) 방식의 angular/react/svelte/vue 같은

프레임워크/라이브러리에서는 이벤트 핸들러 어트리뷰트 방식으로 이벤트를 처리한다.

CBD에서는 HTML, CSS, JS 를 관심사가 다른 개별적인 요소가 아닌, 뷰를 구성하기 위한 구성 요소로 보기 때문에

관심사가 다르다고 생각하지 않는다.

<img src="../../image/deepdive/frameworks.png" width="600" >

<br>

## 이벤트 핸들러 프로퍼티 방식

```html
<body>
    <button>Click me</button>
    <script>
        const $button = document.querySelector('button')
        $button.onclick = () => { alert('button click')}
    </script>
</body>
```

앞서 살펴본 어트리뷰트 방식도 결국 DOM 노드 객체의 이벤트 핸들러 프로퍼티로 변환되므로 결과적으로 이벤트 핸들러 프로퍼티 방식과 동일하다고 할 수 있다.

프로퍼티 방식은 어트리뷰트 방식의 HTML과 JS가 섞이는 문제를 해결할 수 있다.

하지만 이벤트 핸들러 프로퍼티에 하나의 이벤트 핸들러만 바인딩할 수 있다는 단점이 있다.

```html
<body>
    <button>Click me</button>
    <script>
        const $button = document.querySelector('button')
        $button.onclick = function() {
            console.log('button clicked 1')
        }
        $button.onclick = function() {
            console.log('button clicked 2')
        }
    </script>
</body>

<!-- 두번째 바인딩된 이벤트 핸들러에의해 첫번째꺼는 실행되지 않는다.  -->

```

<br>

## addEventListener 메서드 방식


```html
<body>
    <button>Click me</button>
    <script>
        const $button = document.querySelector('button')
        
        $button.addEventListener('click', function() {
            console.log('button click')
        })
    </script>
</body>

```

만일 동일한 html요소에서 발생한 동일한 이벤트에 대해

프로퍼티 방식과 addEventListener메서드 방식을 모두 사용해 이벤트 핸들러를 등록하면 어떻게 동작할까

```html
<body>
    <button>Click me</button>
    <script>
        const $button = document.querySelector('button')
        
        $button.onclick = function() {
            console.log('이벤트 핸들러 프로퍼티 방식')
        }
        $button.addEventListener('click', function() {
            console.log('addEventListener 방식')
        }) 
    </script>
</body>

<!-- add EventListener 메서드 방식은 이벤트 핸들러 프로퍼티에 바인딩된 이벤트 핸들러에 아무런 영향을 주지 않는다.

따라서 2개의 이벤트 핸들러가 모두 호출된다.

프로퍼티 방식은 하나 이상의 이벤트 핸들러를 등록할 수 없지만

addEventListener 방식은 하나 이상의 이벤트 핸들러 등록이 가능.

등록된 순서대로 호출된다. -->


<body>
    <button>Click me</button>
    <script>
        const $button = document.querySelector('button')
        
        $button.addEventListener('click', function() {
            console.log('1버튼 클릭')
        })
        $button.addEventListener('click', function() {
            console.log('2버튼 클릭')
        }) 
    </script>
</body>
```

단, addEventListener 를 통해 참조가 동일한 이벤트 핸들러를 중복 등록하면

하나의 이벤트 핸들러만 등록된다.

```html
<body>
    <button>Click me</button>
    <script>
        const $button = document.querySelector('button')
        
        const handleClick = () => console.log('button click')

        // 참조가 동일한 이벤트 핸들러를 중복 등록 -> 하나만 등록된다.
        $button.addEventListener('click', handleClick)
        $button.addEventListener('click', handleClick) 
    </script>
</body>
```

<br>

## 이벤트 핸들러 제거

addEventListener메서드에 전달한 인수와 removeEventListener 메서드에

전달한 인수가 다르면 이벤트 핸들러가 제거되지 않는다.


```html
<body>
    <button>Click me</button>
    <script>
        const $button = document.querySelector('button')
        
        const handleClick = () => console.log('button click')

        $button.addEventListener('click', handleClick)
        // 두 메서드에 전달하는 인수가 일치하지 않으면 제거되지 않음.
        $button.removeEventListener('click', handleClick, true) //실패
        $button.addEventListener('click', handleClick) //성공
    </script>
</body>
```


무명함수를 이벤트 핸들러로 등록한 경우 제거할 수 없다.

이벤트 핸들러를 제거하려면 이벤트 핸들러의 참조를 변수나 자료구조에 저장하고 있어야 하기 때문.

단, 기명 이벤트 핸들러 내부에서 removeEventListener 메서드를 호출해

이벤트 핸들러를 제거하는 것은 가능.

이때 이벤트 핸들러는 단 한번만 호출된다.

다음의 경우 버튼 요소를 여러번 클릭해도 단 한번만 이벤트 핸들러가 호출된다.

```js
$button.addEventListener('click', function foo(){
    console.log('button click')

    $button.removeEventListener('click', foo)
})
```

<br>

이벤트 핸들러 프로퍼티 방식으로 등록한 이벤트 핸들러는 removeEventListener 메서드로 제거할 수없다.

프로퍼티 방식으로 등록한 이벤트 핸들러를 제거하려면 null을 할당한다.
```html
<script>
        const $button = document.querySelector('button')
        
        const handleClick = () => console.log('button click')

        $button.onclick = handleClick

        $button.removeEventListener('click', handleClick) //실패
        
        //null을 할당해 이벤트 핸들러를 제거한다.
        $button.onclick=null;
</script>
```

<br>

## 이벤트 객체

이벤트 핸들러의 첫번째인수로 이벤트 객체가 전달된다.

```html
<head>
    <style>
        html, body {height: 100%}
    </style>
</head>
<!-- 이벤트 핸들러 어트리뷰트방식의 경우 event가 아닌 다른 이름으로는 이벤트 객체를 전달받지 못한다. -->
<body onclick="showCoords(event)">
    <p>클릭하세요. 클릭한 곳의 좌표가 표시됩니다.</p>
    <em class="message"></em>
    <script>
        const $msg = document.queerySelector('.message')

        function showCoords(e) {
            $msg.textContent = `clientX: ${e.clientX}, clientY:${e.clientY}`
        }
    </script>
</body>

```

```js

onclick="showCoords(event)" 어트리뷰트는 파싱되어 다음과 같은 함수를 암묵적으로 생성하여

onclick이벤트 핸들러 프로퍼티에 할당한다.

function onclick(event) {
    showCoords(event)
}

```

이때 생성된 onclick 이벤트 핸들러의 첫 번째 매개변수 이름이 event로 암묵적으로 명명되기 때문에

event가 아닌 다른 이름으로 이벤트 객체를 전달받지 못한다.

이벤트가 발생하면 암묵적으로 생성되는 이벤트 객체도 생성자 함수에 의해 생성된다.

<br>

이벤트 객체의 프로퍼티는 발생한 이벤트의 타입에 따라 달라진다.

<br>

## 이벤트 객체의 공통 프로퍼티

Event.prototype에 정의되어 있는 이벤트 관련 프로퍼티는 UIEvent, CustomEvent, MouseEvent 등

모든 파생 이벤트 객체에 상속된다.

<img src="../../image/deepdive/e공통프로퍼티.png" width="500" />
<img src="../../image/deepdive/e공통프로퍼티2.png" width="500" />

<br>

currentTarget 프로퍼티는 이벤트 핸들러가 바인딩된 DOM요소를 가리킴.

일반적으로 이벤트 객체의 target 프로퍼티와 currentTarget 프로퍼티는

동일한 DOM 요소를 가리키지만 나중에 살펴볼 이벤트 위임에서는

이벤트 객체의 target 프로퍼티와 currentTarget 프로퍼티가 서로 다른 DOM요소를 가리킬 수 있다.

<br>

## 마우스 정보 취득

MouseEvent 타입의 이벤트 객체는 다음과 같은 고유의 프로퍼티를 갖는다.

- 마우스 포인터의 좌표 정보를 나타내는 프로퍼티
    screenX/screenY, clientX/clinentY, pageX/pageY, offsetX/offsetY

- 버튼 정보를 나타내는 프로퍼티 : altKey, ctrlKey, shiftKey, button

<br>

드래그하는 예제를 생각해보면,

마우스 버튼을 누른 상태(mousedown)에서 mousemove 이벤트가 발생한 시점에 시작하고 

mouseup 이벤트가 발생한 시점에 종료한다.

드래그 시작 시점, 즉 mousedown 이벤트가 발생했을때의 마우스 포인터 좌표와

드래그를 하고 있는 시점, 즉 mousemove 이벤트가 발생할 때마다 마우스 포인터 좌표를 비교해 드래그 대상의 이동 거리를 계산한다.

mouseup 이벤트가 발생하면 드래그가 종료한 것이다.

이때 드래그 대상 요소를 이동시키는 이벤트 핸들러를 제거해 이동을 멈춘다.

<br>

## 이벤트 전파
